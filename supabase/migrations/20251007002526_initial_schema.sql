-- Tabela para armazenar dados adicionais dos clientes
CREATE TABLE public.clientes (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  nome_completo TEXT,
  telefone TEXT,
  endereco TEXT
);
-- Comentário: Esta tabela armazena informações de perfil que não estão na tabela auth.users.

-- Tabela de produtos
CREATE TABLE public.produtos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome TEXT NOT NULL,
  descricao TEXT,
  preco NUMERIC(10, 2) NOT NULL,
  estoque INT NOT NULL DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Comentário: Tabela para gerenciar os produtos do e-commerce.

-- Tabela de pedidos
CREATE TABLE public.pedidos (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  cliente_id UUID NOT NULL REFERENCES public.clientes(id),
  status TEXT NOT NULL DEFAULT 'pendente', -- Ex: pendente, pago, enviado, entregue
  total NUMERIC(10, 2) DEFAULT 0.00,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
-- Comentário: Tabela principal para os pedidos. O cliente_id é uma chave estrangeira para a tabela de clientes.

-- Tabela de junção para itens de um pedido (relação Muitos-para-Muitos)
CREATE TABLE public.itens_pedido (
  pedido_id BIGINT NOT NULL REFERENCES public.pedidos(id),
  produto_id BIGINT NOT NULL REFERENCES public.produtos(id),
  quantidade INT NOT NULL,
  preco_unitario NUMERIC(10, 2) NOT NULL, -- Preço no momento da compra
  PRIMARY KEY (pedido_id, produto_id)
);
-- Comentário: Essencial para que um pedido possa ter múltiplos produtos.

-- Implementação RLS para controle de acesso

-- Habilitar RLS em todas as tabelas relevantes
ALTER TABLE public.clientes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.pedidos ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.itens_pedido ENABLE ROW LEVEL SECURITY;
-- A tabela de produtos não precisa de RLS restritiva, mas habilitamos para permitir acesso de leitura a todos.
ALTER TABLE public.produtos ENABLE ROW LEVEL SECURITY;

-- Políticas de Segurança para a tabela 'clientes'
CREATE POLICY "Clientes podem ver e atualizar seu próprio perfil."
ON public.clientes FOR ALL
USING (auth.uid() = id);

-- Políticas de Segurança para a tabela 'pedidos'
CREATE POLICY "Clientes podem ver seus próprios pedidos."
ON public.pedidos FOR SELECT
USING (auth.uid() = cliente_id);

-- Políticas de Segurança para a tabela 'itens_pedido'
-- Um usuário pode ver os itens de um pedido se ele for o dono do pedido.
CREATE POLICY "Clientes podem ver os itens de seus pedidos."
ON public.itens_pedido FOR SELECT
USING (
  EXISTS (
    SELECT 1 FROM public.pedidos
    WHERE pedidos.id = itens_pedido.pedido_id
    AND pedidos.cliente_id = auth.uid()
  )
);

-- Políticas de Segurança para a tabela 'produtos'
CREATE POLICY "Qualquer usuário autenticado pode ver os produtos."
ON public.produtos FOR SELECT
USING (auth.role() = 'authenticated');

-- Criação de Funções no Banco de dados
-- Função para recalcular o total de um pedido
CREATE OR REPLACE FUNCTION public.recalcular_total_pedido()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  UPDATE public.pedidos
  SET total = (
    SELECT SUM(preco_unitario * quantidade)
    FROM public.itens_pedido
    WHERE pedido_id = NEW.pedido_id
  )
  WHERE id = NEW.pedido_id;
  RETURN NEW;
END;
$$;

-- Criar o trigger que aciona a função após inserções ou atualizações na tabela 'itens_pedido'
CREATE TRIGGER on_itens_pedido_change
AFTER INSERT OR UPDATE OR DELETE ON public.itens_pedido
FOR EACH ROW EXECUTE FUNCTION public.recalcular_total_pedido();

-- Criação de Views

CREATE OR REPLACE VIEW public.detalhes_pedidos AS
SELECT
  p.id AS pedido_id,
  p.created_at AS data_pedido,
  p.status,
  p.total,
  c.id AS cliente_id,
  c.nome_completo AS cliente_nome,
  u.email AS cliente_email,
  json_agg(
    json_build_object(
      'produto_id', prod.id,
      'produto_nome', prod.nome,
      'quantidade', ip.quantidade,
      'preco_unitario', ip.preco_unitario
    )
  ) AS itens
FROM
  public.pedidos p
JOIN
  public.clientes c ON p.cliente_id = c.id
JOIN
  auth.users u ON c.id = u.id
JOIN
  public.itens_pedido ip ON p.id = ip.pedido_id
JOIN
  public.produtos prod ON ip.produto_id = prod.id
GROUP BY
  p.id, c.id, u.email;